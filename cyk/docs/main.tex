\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{amssymb, algorithm, algorithmic}

\sloppy

\renewcommand{\algorithmiccomment}[1]{\hfill $\triangleright$ #1}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Membership in context free languages with CYK\footnote{
    As submitted to the INE410113 class (Theory of Computation). \href{https://github.com/zambonin/ine410113}{Source code}.}}

\author{Douglas Martins\inst{1}, Emmanuel Podestá Jr.\inst{1}, Gustavo Zambonin\inst{1}}

\address{
  Departamento de Informática e Estatística, Universidade Federal de Santa Catarina \\
  88040-900, Florianópolis, Brazil
  \email{\{marcelino.douglas,emmanuel.podesta,gustavo.zambonin\}@posgrad.ufsc.br}
}

\begin{document} 

\maketitle

\section{Introduction}\label{sec:intro}

A formal language can be used as an important instrument to represent syntactic characteristics of logical and mathematical constructs, thus allowing problems from these areas to be expressed differently and solved through an algorithm. For instance, given a piece of code, we wish to know if it is correctly written, according to the rules of its underlying programming language. An algorithm that solves this problem may use a formalism known as a grammar to represent the source code.

A grammar generates every word in a language by means of production rules, that is, a set of transformations. Grammars can be classified, according to the Chomsky hierarchy~\cite{}, in four types: regular, context-free, context-sensitive and unrestricted. This classification is directly related to the classes of problems that languages are able to solve, \emph{i.e.} unrestricted grammars can solve the most complex problems that are still computable. Furthermore, note that every problem with a Boolean answer can be expressed as a membership problem in a language (the set of words that represent positive solutions). Algorithms that solve these problems in the context of grammars are called parsers.

As discussed above, syntax of programming languages is usually described in the form of a context-free grammar. This happens because regular languages cannot deal with common source code idioms, such as the presence of balanced parenthesis. Even though this description is concise, the act of parsing strings may be computationally complex. Hence, we make use of strategies such as the conversion of context-free grammars into an equivalent grammar in Chomsky normal form (CNF), that allows easier parsing of strings through an even simpler description of the grammar.

This is exactly the situation presented in~\cite{}. Context-free grammars in CNF are given, and a parser must be written to solve the problem. We choose the CYK algorithm, present it in Section~\ref{sec:cyk} and discuss the solution programmed in Section~\ref{sec:imp}.

\section{Cocke–Younger–Kasami algorithm}\label{sec:cyk}

The CYK algorithm was discovered independently by Cocke~\cite{}, Younger~\cite{} and Kasami~\cite{}. It is a bottom-up parser that uses dynamic programming to decide whether a word is member of a context-free language. Consider a grammar as a $4$-tuple $G = (V, \Sigma, R, S)$, where $V$ is a finite set of variables, $\Sigma$ is a finite set of terminals such that $V \cap \Sigma = \emptyset$, $S \in V$ is the start variable, and $\forall A, B, C \in V, \forall \alpha \in \Sigma$, $R$ is a finite set of rules with the forms $A \rightarrow \alpha$ or $A \rightarrow BC$. This definition of a CNF grammar is due to Sipser~\cite{}, and note that converting any context-free grammar to its equivalent CNF normal form is possible~\cite{}. We present a description of CYK in Algorithm~\ref{alg:cyk} and discuss it below.

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \REQUIRE{} $w \in \Sigma^{*}, G$
      \COMMENT{word, grammar in CNF}
    \ENSURE{} $v \in \{\mathbf{T}, \mathbf{F}\}$
      \COMMENT{Boolean value that represents whether $w \in G$}
    \STATE{} $n \leftarrow |w|$
      \COMMENT{size of $w$}
    \STATE{} $d \leftarrow [\{\}_{0}^{0}, \dots, \{\}_{n - 1}^{0}, \{\}_{0}^{1}, \dots, \{\}_{n - 1}^{n - 1}]$
      \COMMENT{square $n \times n$ matrix of empty sets}
    \FOR{$i \leftarrow 0, \dots, n - 1$}
      \IF{$(A \rightarrow w[i]) \in G.R$}
        \STATE{} $d_{i}^{i} \leftarrow d_{i}^{i} \cup \{A\}$
          \COMMENT{if rule produces the $i$-th letter of $w$}
      \ENDIF{}
    \ENDFOR{}
    \FOR{$\ell \leftarrow 1, \dots, n - 1$}
      \FOR{$r \leftarrow 0, \dots, n - \ell - 1$} 
        \FOR{$t \leftarrow 0, \dots, \ell - 1$}
          \STATE{} $\mathcal{L} \leftarrow d_{r}^{r + t}$
            \COMMENT{rules that generate the $w[r:r+t]$ prefixes}
          \STATE{} $\mathcal{R} \leftarrow d_{r + t + 1}^{r + \ell}$
            \COMMENT{rules that generate the $w[r + t + 1:r + \ell]$ suffixes}
          \FOR{$(B, C) \in \mathcal{L} \times \mathcal{R}$}
            \IF{$(A \rightarrow BC) \in G.R$}
              \STATE{} $d_{r}^{r + \ell} \leftarrow d_{r}^{r + \ell} \cup \{A\}$
                \COMMENT{if rule produces the pair, in that order}
            \ENDIF{}
          \ENDFOR{}
        \ENDFOR{}
      \ENDFOR{}
    \ENDFOR{}
    \STATE{} $v \leftarrow (S \in d_{0}^{n - 1})$
      \COMMENT{if the starting rule is in the lower left matrix cell}
  \end{algorithmic}
  \caption{CYK algorithm}\label{alg:cyk}
\end{algorithm}

The main notion of CYK is the fact that every word in the language can be subdivided into a prefix and a suffix, starting with the base case, when there are only terminals, exhibiting its bottom-up nature. The CNF restriction for rules allows exactly this splitting behavior. Dynamic programming is employed to solve smaller problems, \emph{i.e.} check if substrings of an input are in the language.

Consider Algorithm~\ref{alg:cyk}. We create a lower triangular $n \times n$ matrix $d$, and by Lines 3--7, its diagonal is filled with all rules that produce each letter in $w$.

The algorithm has a complexity of $\mathcal{O}(n^{3} \cdot s)$, $n$ as above and $s$ as the quantity of variables and terminals for every $r \in R$. Intuitively, this is the case since there are $n^{2}$ cells in the matrix $d$, each populated with a set linear in size. Furthermore, this happens because, unlike parsers that are restricted to specific types of grammars, CYK can parse every context-free grammar. Still, it was proven by Lee~\cite{} that context-free parsing is equivalent to Boolean matrix multiplication, thus implying that this complexity can be turned sub-cubic.

\section{Implementation}\label{sec:imp}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}