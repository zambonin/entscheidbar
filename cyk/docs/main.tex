\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amssymb}

\sloppy

\title{Membership in context free languages \\ with the CYK algorithm\footnote{
    As submitted to the INE410113 class (Theory of Computation).}}

\author{Douglas Martins\inst{1}, Emmanuel Podestá Jr.\inst{1}, Gustavo Zambonin\inst{1}}

\address{
  Departamento de Informática e Estatística, Universidade Federal de Santa Catarina \\
  88040-900, Florianópolis, Brazil
  \email{\{marcelino.douglas,emmanuel.podesta,gustavo.zambonin\}@posgrad.ufsc.br}
}

\begin{document} 

\maketitle

\section{Introduction}\label{sec:intro}
A formal language can be used as an important instrument to represent syntactic characteristics of logical and mathematical constructs, thus allowing problems from these areas to be expressed differently and solved through an algorithm. For instance, given a piece of code, we wish to know if it is correctly written, according to the rules of its underlying programming language. An algorithm that solves this problem may use a formalism known as a grammar to represent the source code.

A grammar generates every word in a language by means of production rules, that is, a set of transformations. Grammars can be classified, according to the Chomsky hierarchy~\cite{}, in four types: regular, context-free, context-sensitive and unrestricted. This classification is directly related to the classes of problems that languages are able to solve, \emph{i.e.} unrestricted grammars can solve the most complex problems that are still computable. Furthermore, note that every problem with a Boolean answer can be expressed as a membership problem in a language (the set of words that represent positive solutions). Algorithms that solve these problems in the context of grammars are called parsers.

As discussed above, syntax of programming languages is usually described in the form of a context-free grammar. This happens because regular languages cannot deal with common source code idioms, such as the presence of balanced parenthesis. Even though this description is concise, the act of parsing strings in accordance to a grammar may be computationally complex. Hence, we make use of strategies such as the conversion of context-free grammars into an equivalent grammar in Chomsky normal form, that allows easier parsing of strings.

% Composed by a set of strings of symbols, a formal language can be used as a important instrument to solve problems (which problems?). 


% We can define a formal language through a grammar, which is a structure able to generate every word in the language (how?). Grammars can be classified as regular, context-free, context-sensitive or even unrestricted, according to the Chomsky hierarchy~\cite{}. The classification of grammars comes from the classes of problems that each language generated by each grammar are capable to solve, with regular being the simplest class of problems and the unrestricted the most complex class.

% One application of formal languages is the description of programming languages. We can use a context-free grammar to describe their syntactic rules, \emph{e.g.} a compiler gets as input a source code and uses its grammar to check if the lines of code are syntactically correct, in other words, if the source code is a "member of the language". 

% The process of analyzing a word and checking its membership in a language, considering the rules of a grammar, is called parsing. There exists different types of parsers, according to the different types of languages. For the context-free languages, where the grammar are in Chomsky normal formal, we can use the Cocke–Younger–Kasami (CYK) algorithm. 






% Introduce the problem; explain what is the goal of a parsing algorithm; given a context-free grammar $G$ and a word $w$ as input, is it possible to check if $w$ is a member of the language generated by $G$? In our case, consider only grammars in Chomsky normal form.

\section{Cocke–Younger–Kasami algorithm}\label{sec:cyk}

\section{Implementation}\label{sec:imp}


\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
