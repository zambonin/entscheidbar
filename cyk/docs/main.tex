\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{amssymb, algorithm, algorithmic}

\sloppy

\renewcommand{\algorithmiccomment}[1]{\hfill $\triangleright$ #1}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Membership in context free languages with CYK\footnote{
    As submitted to the INE410113 class (Theory of Computation). \href{https://github.com/zambonin/ine410113}{Source code}.}}

\author{Douglas Martins\inst{1}, Emmanuel Podestá Jr.\inst{1}, Gustavo Zambonin\inst{1}}

\address{
  Departamento de Informática e Estatística, Universidade Federal de Santa Catarina \\
  88040-900, Florianópolis, Brazil
  \email{\{marcelino.douglas,emmanuel.podesta,gustavo.zambonin\}@posgrad.ufsc.br}
}

\begin{document} 

\maketitle

\section{Introduction}\label{sec:intro}

A formal language can be used as an important instrument to represent syntactic characteristics of logical and mathematical constructs, thus allowing problems from these areas to be expressed differently and solved through an algorithm. For instance, given a piece of code, we wish to know if it is correctly written, according to the rules of its underlying programming language. An algorithm that solves this problem may use a formalism known as a grammar to represent the source code.

A grammar generates every word in a language by means of production rules, that is, a set of transformations. Grammars can be classified, according to the Chomsky hierarchy~\cite{}, in four types: regular, context-free, context-sensitive and unrestricted. This classification is directly related to the classes of problems that languages are able to solve, \emph{i.e.} unrestricted grammars can solve the most complex problems that are still computable. Furthermore, note that every problem with a Boolean answer can be expressed as a membership problem in a language (the set of words that represent positive solutions). Algorithms that solve these problems in the context of grammars are called parsers.

As discussed above, syntax of programming languages is usually described in the form of a context-free grammar. This happens because regular languages cannot deal with common source code idioms, such as the presence of balanced parenthesis. Even though this description is concise, the act of parsing strings may be computationally complex. Hence, we make use of strategies such as the conversion of context-free grammars into an equivalent grammar in Chomsky normal form (CNF), that allows easier parsing of strings through an even simpler description of the grammar.

This is exactly the situation presented in~\cite{}. Context-free grammars in Chomsky normal form are given, and a parser must be written to solve the problem. We choose the Cocke–Younger–Kasami (CYK) algorithm, present it in Section~\ref{sec:cyk} and discuss the solution programmed in Section~\ref{sec:imp}.

\section{Cocke–Younger–Kasami algorithm}\label{sec:cyk}


\begin{algorithm}
  \begin{algorithmic}
    \REQUIRE{} $w \in \Sigma^{*}, G$
      \COMMENT{word, grammar in CNF}
    \ENSURE{} $v \in \{\mathbf{T}, \mathbf{F}\}$
      \COMMENT{Boolean value that represents whether $w \in G$}
    \STATE{} $n \leftarrow |w|$
      \COMMENT{size of $w$}
    \STATE{} $d \leftarrow [\{\}_{0}^{0}, \dots, \{\}_{n - 1}^{n - 1}]$
      \COMMENT{square $n \times n$ matrix of empty sets}
    \FOR{$i \leftarrow 0, \dots, n - 1$}
      \FOR{$A \in G.V$}
        \IF{$(A \rightarrow w[i]) \in G.R$}
          \STATE{} $d_{i}^{i} \leftarrow d_{i}^{i} \cup \{A\}$
        \ENDIF{}
      \ENDFOR{}
    \ENDFOR{}
    \FOR{$\ell \leftarrow 1, \dots, n - 1$}
      \FOR{$r \leftarrow 0, \dots, n - \ell - 1$}
        \FOR{$t \leftarrow 0, \dots, \ell - 1$}
          \FOR{$(B, C) \in d_{r}^{r + t} \times d_{r + t + 1}^{r + \ell}$}
            \IF{$(A \rightarrow BC) \in G.R$}
              \STATE{} $d_{r}^{r + \ell} \leftarrow d_{r}^{r + \ell} \cup \{A\}$
            \ENDIF{}
          \ENDFOR{}
        \ENDFOR{}
      \ENDFOR{}
    \ENDFOR{}
    \STATE{} $v \leftarrow (S \in d_{0}^{n - 1})$
  \end{algorithmic}
  \caption{Cocke–Younger–Kasami algorithm.}\label{alg:cyk}
\end{algorithm}

\section{Implementation}\label{sec:imp}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}

