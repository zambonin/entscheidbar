\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amssymb}

\sloppy

\title{Computational Models Equivalent to Turing Machines\footnote{
    As submitted to the INE410113 class (Theory of Computation).}}

\author{Douglas Martins\inst{1}, Emmanuel Podestá Jr.\inst{1}, Gustavo Zambonin\inst{1}}

\address{
  Departamento de Informática e Estatística, Universidade Federal de Santa Catarina \\
  88040-900, Florianópolis, Brazil
  \email{\{marcelino.douglas,emmanuel.podesta,gustavo.zambonin\}@posgrad.ufsc.br}
}

\begin{document} 

\maketitle

\section{Introduction}\label{sec:intro}
 
Solving problems is paramount to the advance of society, often being useful to accelerate development in any discipline. By defining a finite number of instructions that may produce outputs fully determined by respective inputs, one creates an algorithm. This historic notion, that which of an ``effective method'' for computations, was subsequently formalised independently by Church~\cite{}, with its $\lambda$-calculus, and Turing, through Turing machines~\cite{}, equivalent models of computation that yield a class of functions known as computable functions. Without loss of generality, these can be thought of as some partial functions on natural numbers, that is, $f : \mathbb{N}^{k} \rightarrow \mathbb{N}$, such that any $k$-tuple will give $f(x)$ through an effective method. 

Note that this computational process may actually never stop, \emph{i.e.} $f(x)$ may be an undefined value. It would be interesting to determine this behaviour for any combination of algorithms --- or ``computer programs'' --- and inputs. Called the halting problem, this was proved to be impossible to solve through the Turing machine model of computation. It is not a computable function, that is, there is no algorithm that accurately determines whether an arbitrary algorithm will halt. The halting problem is frequently featured when models are proven to be equivalent to Turing machines, and will aid to clarify the reasoning behind these.

Models of computation that can simulate Turing machines are called Turing-complete, or universal, and Turing-equivalent if a Turing machine can simulate that model. These definitions are the same in practice, since all Turing-complete systems known are also Turing-equivalent (by the Church--Turing thesis, this should remain the case for any computable functions). To efficiently study models whose Turing-equivalence may not be obvious, we recall the definition of a Turing machine and give descriptions of such models in terms of these machines.

A Turing machine consists of a finite number of states, and features an infinite one-dimensional tape divided into cells, each of which holds a symbol from a finite tape alphabet. A tape head is always positioned at exactly one of the cells, and can write to that cell, move to its left or right neighbours, or order the machine to change states. The input, consisting of words from a subset of the tape alphabet, is placed on the tape, each symbol in its own cell, and all others initialised to blank, a special symbol from the tape alphabet, and the tape head rests on the leftmost filled cell. The tape is moved according to a series of instructions.

Formally, it is defined as a $7$-tuple $M = (Q, \Gamma, \Sigma, \delta, q_{0}, B, F)$, in which $Q$ is a finite, non-empty set of states, $\Gamma$ is a finite, non-empty tape alphabet, $\Sigma \subset \Gamma$ is a non-empty input alphabet, $B \in \Gamma, B \not\in \Sigma$ is the blank symbol, $q_{0} \in Q$ is the initial state, $F \subseteq Q$ is a set of accepting states, and $\delta : $

% algorithms are used to solve problems, but not all problems can be solved by algorithms
% to talk about solvable problems is to talk about computable functions, general primitive recursive functions and nothing else like I/O or fluff
% however, we cannot talk about computable functions without talking about its models of computation, that is, how exactly a set of outputs is computed given a set of inputs, describing memory, units, communications etc
% the main model known is the universal turing machine, and all functions that are computable, are computable ith this model
% the church-turing thesis states that all computing systems capable of general computation are equally powerful
% many others have been created and shown to be equivalent to turing machines
% henceforth we explore curious and/or incommon models of computation that are turing-complete, and consequently, equivalent (talk about difference between equivalence and completeness)
% however note that expressiveness of these models may be limited (how difficult they are to program)
% as such, namely, we will talk about cellular automata, string rewriting systems and Diophantine equations, and how these can be used to construct valid models of computation

% \emph{Organization.} This paper is organized as follows. 

\section{Conclusion}\label{sec:conc}

% in this work we have seen some models of computation that have applications outside theory of computation, like mathematics and biology
% further, these are interchangeable in the sense that one can be represented in the other
% other examples feature lambda calculus, most programming languages (if infinite memory), and even some videogames
% hence, turing completeness is an interesting property of models

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
