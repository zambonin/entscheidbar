\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{amssymb, amsmath, algorithm, algorithmic, color, listings}

\definecolor{codegreen}{rgb}{0, 0.6, 0}
\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}
\definecolor{codepurple}{rgb}{0.58, 0, 0.82}

\lstset{
  basicstyle=\tiny\ttfamily,
  breaklines=true,
  commentstyle=\color{codegreen},
  extendedchars=true,
  keywordstyle=\color{blue},
  numbers=left,
  numberstyle=\tiny\color{codegray},
  showstringspaces=false,
  stringstyle=\color{codepurple}
}

\sloppy

\renewcommand{\algorithmiccomment}[1]{\hfill $\triangleright$ #1}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Solution to a Simplified Halting Problem\footnote{
    As submitted to the INE410113 class (Theory of Computation). \href{https://github.com/zambonin/ine410113}{Source code}.}}

\author{Douglas Martins\inst{1}, Emmanuel Podestá Jr.\inst{1}, Gustavo Zambonin\inst{1}}

\address{Departamento de Informática e Estatística, Universidade Federal de Santa Catarina \\
  88040-900, Florianópolis, Brazil
  \email{\{marcelino.douglas,emmanuel.podesta,gustavo.zambonin\}@posgrad.ufsc.br}
}

\begin{document} 

\maketitle

\section{Introduction}\label{sec:intro}

\section{Simplified Halting Problem}\label{sec:halting}

It is known that there exists no procedure which can determine if a program halts or not, as seen above. However, 

\section{Implementation}\label{sec:imp}

The full source code for the language parsing and execution unit can be read in Appendix~\ref{app:impl}. We shortly discuss it in the sequence. Data structures were carefully chosen to prevent data access overhead. As such, unordered maps and sets are heavily featured, since their underlying STL implementation is a red-black tree. Additionally, hashing functions were created, to enable insertion of custom structures into these containers. 

We parse the input with regular expression rules created from the description of the problem~\cite{Demasi:misc:2013:may} and check for any syntax errors. We must note that, while the program description says that arithmetic is limited to modular arithmetic modulo $1000$, there exists a wrong input program that features exactly this number. Hence, the program has a workaround to accept this variable. Helper functions that translate values from the ``memory'' and parse each program line into a valid ``instruction'' are given shortly below.

Lines 113--158 present the function that loops over an entire program and evaluates its lines, following the control flow if needed. It takes into account a ``program counter'' and a recursion stack, essential to simulate the inner works of the toy language. If instructions are arithmetic or conditional, a function map is invoked to decide what should be executed. Further, in the case of arithmetic functions, recall that operations have to follow a set of rules that, for instance, allow division by zero.

The most complex behaviour of the code, however, is met when parsing instructions that enter and exit recursion states. An optimisation is added here, that features memoisation of previously calculated recursion states. This allows the code to pass the $\frac{1}{8}$ of a second time target, since there are input programs that calculate large Fibonacci numbers, and it is known that if intermediary results are not memoised, this calculation will take a very long time. Evidently, the recursion stack is modified, the ``program counter'' is reset, and values are returned as usual.

Within this code, the strategy for preventing infinite loops is also implemented. It is enough to compare the last two recursion states for equality, as discussed above. Note that the hashing function used in this comparison was not carefully constructed as to prevent collisions, but it seems to distribute all ``memory'' states distinctly. Finally, once the instruction is parsed, the ``program counter'' is incremented and the program may return if it finished its execution.

All programs are executed and results are printed according to the problem definition. After determining its correct parsing and execution of the toy language, the code was taking $30$ ms to calculate the entirety of the input. Parsing instructions takes a considerable amount of time, but this cannot be memoised, \emph{e.g.} \texttt{ADD R1,R2} may appear in two programs, but have completely different meanings depending on the contents of the ``memory'' at each ``program counter'' state.

Using simpler string structures, manual translation of strings to integers, and substituting the ``memory'' from a map to an array lead the code to execute in $8$ ms. Correctly emulating recursion loops, as well as these performance improvements, were the main obstacles. Further optimisations can be achieved if large parts of the code is rewritten, for instance, removing function maps and regular expressions. Ergo, to prevent reduction of code readability and maintenance, we leave it as is.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\appendix

\section{C++ implementation of Simplified Halting Problem}\label{app:impl}
\lstinputlisting[language=C++]{halting.cpp}

\end{document}